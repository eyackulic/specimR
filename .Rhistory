cropImage <- function(raw){
image <- raster::subset(raw,c(1,5,8))
raster::plotRGB(raw,c(1,5,8), axes=TRUE, stretch="hist", main="Raw Image")
cropC <- raster::drawExtent()
stripe <- raster::crop(raw,cropC)
names(stripe) <- names(raw)
return(stripe)
}
WhiteRef <-function(stripe,directory,id){
white <- file.path(directory,paste("WHITEREF_",id,".raw",sep=""))
if(missing(white))  white <- tcltk::tk_choose.files(caption="choose 'WHITEREF' File",filter = Filters)
whiteRow <- createReferenceMeanRow(refFile=white,e=stripe,outfile="WhiteRow.tif",spectra=spectra)
names(whiteRow) <- names(stripe)
#find length of core stripe to break up white
len <- stripe@nrows
#disaggregate whiterow to length
white.ref <- disaggregate(whiteRow,fact = c(1,len))
#set extents to be the same between stripe and reference files
extent(white.ref) <- extent(stripe)
return(white.ref)
}
DarkRef <- function(stripe,directory,id){
dark <- file.path(directory,paste("DARKREF_",id,".raw",sep=""))
if(missing(dark))  dark <- tcltk::tk_choose.files(caption="choose 'DARKREF' File",filter = Filters)
darkRow <- createReferenceMeanRow(refFile=dark,e=stripe,outfile="DarkRow.tif",spectra=spectra)
names(darkRow) <- names(stripe)
len <- stripe@nrows
dark.ref <- disaggregate(darkRow,fact = c(1,len))
extent(dark.ref) <- extent(stripe)
return(dark.ref)
}
overlayR <- function(stripe,whiteRef,darkRef){
normalized <- raster::overlay(stripe,whiteRef,darkRef,fun = normFun,filename = "normalized.tif",overwrite = TRUE)
names(normalized) <- names(stripe)
return(normalized)
}
normalize <- function(id,spectra,directory,tif.path.to.write = NA){
#choose and load the file
raw <- filechooseR(id = id,
spectra = spectra,
directory = directory)
#crop the image
stripe <- cropImage(raw)
#load in the white and dark refs
white.ref <- WhiteRef(stripe,id,directory)
dark.ref <- DarkRef(stripe,id,directory)
#now normalize
normalized <- overlayR(stripe, white.ref, dark.ref)
#optionally write to a tif
if(!is.na(tif.path.to.write)){
writeTif(normalized, path = tif.path.to.write)
}
return(normalized)
}
createReferenceMeanRow <- function(refFile,e,outFile,spectra){
refBrick <- brick(refFile)
refBrick <-  raster::subset(refBrick,spectra)
#crop it by the earlier crop width
ebb <- extent(refBrick)
ex <- extent(e)
ebb@xmin <- ex@xmin
ebb@xmax <- ex@xmax
refBrick <- crop(refBrick,ebb)
rbcm <- colSums(refBrick)/nrow(refBrick)
#preallocate
r <- brick(ncol=ncol(refBrick), nrow=1,nl = dim(refBrick)[3], xmn=ex@xmin, xmx=ex@xmax, ymn=0, ymx=1)
r <- setValues(r,rbcm)
#save row for later processing.
writeRaster(r,filename = file.path("..",outFile), overwrite = TRUE)
}
createReferenceMeanRow2 <- function(refFile,e){
refBrick <- brick(refFile)
#crop it by the earlier crop width
ebb <- extent(refBrick)
ex <- extent(e)
ebb@xmin <- ex@xmin
ebb@xmax <- ex@xmax
refBrick <- crop(refBrick,ebb)
r <- aggregate(refBrick,fact = c(1,nrow(refBrick)),fun = mean)
return(r)
}
createReferenceTif <- function(meanRow,targetExtent,fileOut){
#calculate number of rows in target
nrs <- floor(targetExtent@ymax - targetExtent@ymin)
#load in the row
if(is.character(meanRow)){#load in the file
meanRow <- brick(meanRow)
}
ref <- meanRow
print(ref)
while(nrow(ref)<nrs){
#duplicate prior chunk
newChunk <- ref
#adjust the extent to go below the last chunk
re <- extent(ref)
nr <- nrow(ref)
re@ymin <- re@ymax
re@ymax <- re@ymin+nr
extent(newChunk) <- re
#check to see if it will be too big
if(nrow(newChunk)*2 > nrs){
needed <-  nrs-nrow(newChunk)
ne <- extent(ref)
ne@ymax <- ne@ymax+needed
newChunk <- crop(newChunk,ne)
}
ref <- merge(ref,newChunk)
print(nrow(ref))
}
#adjust extent to match
extent(ref) <- targetExtent
#options   = "COMPRESS=LZW",
writeRaster(ref,filename = file.path("..",fileOut),overwrite = TRUE,progress = "text")
}
normFun <- function(data,white,dark){
s1 <- (data - dark)
s1[is.na(s1)] <- 0
s1[s1<0] <- 0
return(s1 / (white - dark))
}
createReferenceTif2 <- function(meanRow,targetExtent,fileOut){
#calculate number of rows in target
nrs <- floor(targetExtent@ymax - targetExtent@ymin)
#load in the row
if(is.character(meanRow)){#load in the file
meanRow <- brick(meanRow)
}
ref <- meanRow
print(ref)
while(nrow(ref)<nrs){
#duplicate prior chunk
newChunk <- ref
#chunk 1
#adjust the extent to go below the last chunk
re <- extent(ref)
nr <- nrow(ref)
re@ymin <- re@ymax
re@ymax <- re@ymin+nr
extent(newChunk) <- re
#chunk 2
newChunk2 <- newChunk
re <- extent(newChunk)
nr <- nrow(newChunk)
re@ymin <- re@ymax
re@ymax <- re@ymin+nr
extent(newChunk2) <- re
#chunk 3
newChunk3 <- newChunk2
re <- extent(newChunk2)
nr <- nrow(newChunk2)
re@ymin <- re@ymax
re@ymax <- re@ymin+nr
extent(newChunk3) <- re
#check to see if it will be too big
if(nrow(newChunk)*4 > nrs){
needed <-  nrs-nrow(newChunk)
ne <- extent(ref)
ne@ymax <- ne@ymax+needed
newChunk <- crop(newChunk,ne)
}
ref <- merge(ref,newChunk,newChunk2,newChunk3)
print(nrow(ref))
}
#adjust extent to match
extent(ref) <- targetExtent
#options   = "COMPRESS=LZW",
writeRaster(ref,filename = file.path("..",fileOut),overwrite = TRUE,progress = "text")
}
#choose band_names
spectra <- c("X569.71","X589.88","X615.22","X630.49","X659.89","X665.02","X689.43","X730.74","X790.43","X845.12","X899.86")
id <- "Lakes380_FORSY_LC1U_2B_test_2020-06-05_04-05-39"
(directory <- setwd("/Volumes/easystore/Forsy"))
core <- normalize(directory=directory,id=id,spectra=spectra)
core <- normalize(directory=directory,id=id,spectra=spectra)
raw <- filechooseR(id=id,directory=directory,spectra=spectra)
stripe <- cropImage(raw)
whiteRef <-WhiteRef(stripe=stripe,directory = directory,id=id)
darkRef <-DarkRef(stripe,directory=directory,id=id)
normalized <- overlayR(stripe,whiteRef,darkRef)
normalized
#'
filechooseR <- function(id,
directory = NA,
spectra){
Filters <- matrix(c("*",".raw"),1, 2, byrow = TRUE)
data <- file.path(directory,paste(id,".raw",sep=""))
if(missing(data)) data <- tcltk::tk_choose.files(caption="choose Data File",filter = Filters)
filen <- raster::brick(data)
raw <- raster::subset(filen,spectra)
return(raw)
}
cropImage <- function(raw){
image <- raster::subset(raw,c(1,5,8))
raster::plotRGB(raw,c(1,5,8), axes=TRUE, stretch="hist", main="Raw Image")
cropC <- raster::drawExtent()
stripe <- raster::crop(raw,cropC)
names(stripe) <- names(raw)
return(stripe)
}
WhiteRef <-function(stripe,directory,id){
white <- file.path(directory,paste("WHITEREF_",id,".raw",sep=""))
if(missing(white))  white <- tcltk::tk_choose.files(caption="choose 'WHITEREF' File",filter = Filters)
whiteRow <- createReferenceMeanRow(refFile=white,e=stripe,outfile="WhiteRow.tif",spectra=spectra)
names(whiteRow) <- names(stripe)
#find length of core stripe to break up white
len <- stripe@nrows
#disaggregate whiterow to length
white.ref <- disaggregate(whiteRow,fact = c(1,len))
#set extents to be the same between stripe and reference files
extent(white.ref) <- extent(stripe)
return(white.ref)
}
DarkRef <- function(stripe,directory,id){
dark <- file.path(directory,paste("DARKREF_",id,".raw",sep=""))
if(missing(dark))  dark <- tcltk::tk_choose.files(caption="choose 'DARKREF' File",filter = Filters)
darkRow <- createReferenceMeanRow(refFile=dark,e=stripe,outfile="DarkRow.tif",spectra=spectra)
names(darkRow) <- names(stripe)
len <- stripe@nrows
dark.ref <- disaggregate(darkRow,fact = c(1,len))
extent(dark.ref) <- extent(stripe)
return(dark.ref)
}
overlayR <- function(stripe,white.ref,dark.ref){
normalized <- raster::overlay(stripe,white.ref,dark.ref,fun = normFun,filename = "normalized.tif",overwrite = TRUE)
names(normalized) <- names(stripe)
return(normalized)
}
normalize <- function(id,spectra,directory,tif.path.to.write = NA){
#choose and load the file
raw <- filechooseR(id = id,
spectra = spectra,
directory = directory)
#crop the image
stripe <- cropImage(raw)
#load in the white and dark refs
white.ref <- WhiteRef(stripe,id,directory)
dark.ref <- DarkRef(stripe,id,directory)
#now normalize
normalized <- overlayR(stripe, white.ref, dark.ref)
#optionally write to a tif
if(!is.na(tif.path.to.write)){
writeTif(normalized, path = tif.path.to.write)
}
return(normalized)
}
normalize(id=id,spectra = spectra,directory=directory)
createReferenceMeanRow <- function(refFile,e,outFile=NA,spectra){
refBrick <- brick(refFile)
refBrick <-  raster::subset(refBrick,spectra)
#crop it by the earlier crop width
ebb <- extent(refBrick)
ex <- extent(e)
ebb@xmin <- ex@xmin
ebb@xmax <- ex@xmax
refBrick <- crop(refBrick,ebb)
rbcm <- colSums(refBrick)/nrow(refBrick)
#preallocate
r <- brick(ncol=ncol(refBrick), nrow=1,nl = dim(refBrick)[3], xmn=ex@xmin, xmx=ex@xmax, ymn=0, ymx=1)
r <- setValues(r,rbcm)
#save row for later processing.
writeRaster(r,filename = file.path("..",outFile), overwrite = TRUE)
}
WhiteRef <-function(stripe,directory,id){
white <- file.path(directory,paste("WHITEREF_",id,".raw",sep=""))
if(missing(white))  white <- tcltk::tk_choose.files(caption="choose 'WHITEREF' File",filter = Filters)
whiteRow <- createReferenceMeanRow(refFile=white,e=stripe,spectra=spectra)
names(whiteRow) <- names(stripe)
#find length of core stripe to break up white
len <- stripe@nrows
#disaggregate whiterow to length
white.ref <- disaggregate(whiteRow,fact = c(1,len))
#set extents to be the same between stripe and reference files
extent(white.ref) <- extent(stripe)
return(white.ref)
}
normalize(id=id,spectra = spectra,directory=directory)
createReferenceMeanRow <- function(refFile,e,outFile,spectra){
refBrick <- brick(refFile)
refBrick <-  raster::subset(refBrick,spectra)
#crop it by the earlier crop width
ebb <- extent(refBrick)
ex <- extent(e)
ebb@xmin <- ex@xmin
ebb@xmax <- ex@xmax
refBrick <- crop(refBrick,ebb)
rbcm <- colSums(refBrick)/nrow(refBrick)
#preallocate
r <- brick(ncol=ncol(refBrick), nrow=1,nl = dim(refBrick)[3], xmn=ex@xmin, xmx=ex@xmax, ymn=0, ymx=1)
r <- setValues(r,rbcm)
#save row for later processing.
writeRaster(r,filename = file.path("..",outFile), overwrite = TRUE)
}
source('~/Documents/GitHub/specimR/R/standardize.R')
source('~/Documents/GitHub/specimR/R/standardize.R')
source('~/Documents/GitHub/specimR/R/normalize.R')
normalize(id=id,spectra = spectra,directory=directory)
normalize(id=id,spectra = spectra,directory=directory)
raw <- filechooseR(id=id,directory=directory,spectra=spectra)
stripe <- cropImage(raw)
whiteRef <-WhiteRef(stripe=stripe,directory = directory,id=id)
darkRef <-DarkRef(stripe,directory=directory,id=id)
normalized <- overlayR(stripe,whiteRef,darkRef)
raw <- filechooseR(id=id,directory=directory,spectra=spectra)
stripe <- cropImage(raw)
whiteRef <-WhiteRef(stripe=stripe,directory = directory,id=id)
WhiteRef <-function(stripe,directory,id){
white <- file.path(directory,paste("WHITEREF_",id,".raw",sep=""))
if(missing(white))  white <- tcltk::tk_choose.files(caption="choose 'WHITEREF' File",filter = Filters)
whiteRow <- createReferenceMeanRow(white,stripe,spectra)
names(whiteRow) <- names(stripe)
#find length of core stripe to break up white
len <- stripe@nrows
#disaggregate whiterow to length
white.ref <- disaggregate(whiteRow,fact = c(1,len))
#set extents to be the same between stripe and reference files
extent(white.ref) <- extent(stripe)
return(white.ref)
}
DarkRef <- function(stripe,directory,id){
dark <- file.path(directory,paste("DARKREF_",id,".raw",sep=""))
if(missing(dark))  dark <- tcltk::tk_choose.files(caption="choose 'DARKREF' File",filter = Filters)
darkRow <- createReferenceMeanRow(refFile=dark,e=stripe,outfile="DarkRow.tif",spectra=spectra)
names(darkRow) <- names(stripe)
len <- stripe@nrows
dark.ref <- disaggregate(darkRow,fact = c(1,len))
extent(dark.ref) <- extent(stripe)
return(dark.ref)
}
overlayR <- function(stripe,white.ref,dark.ref){
normalized <- raster::overlay(stripe,white.ref,dark.ref,fun = normFun,filename = "normalized.tif",overwrite = TRUE)
names(normalized) <- names(stripe)
return(normalized)
}
normalize <- function(id,spectra,directory,tif.path.to.write = NA){
#choose and load the file
raw <- filechooseR(id = id,
spectra = spectra,
directory = directory)
#crop the image
stripe <- cropImage(raw)
#load in the white and dark refs
white.ref <- WhiteRef(stripe,id,directory)
dark.ref <- DarkRef(stripe,id,directory)
#now normalize
normalized <- overlayR(stripe, white.ref, dark.ref)
#optionally write to a tif
if(!is.na(tif.path.to.write)){
writeTif(normalized, path = tif.path.to.write)
}
return(normalized)
}
WhiteRef <-function(stripe,directory,id){
white <- file.path(directory,paste("WHITEREF_",id,".raw",sep=""))
if(missing(white))  white <- tcltk::tk_choose.files(caption="choose 'WHITEREF' File",filter = Filters)
whiteRow <- createReferenceMeanRow(white,stripe,outFile,spectra)
names(whiteRow) <- names(stripe)
#find length of core stripe to break up white
len <- stripe@nrows
#disaggregate whiterow to length
white.ref <- disaggregate(whiteRow,fact = c(1,len))
#set extents to be the same between stripe and reference files
extent(white.ref) <- extent(stripe)
return(white.ref)
}
whiteRef <-WhiteRef(stripe=stripe,directory = directory,id=id)
source('~/Documents/GitHub/specimR/R/normalize.R')
whiteRef <-WhiteRef(stripe=stripe,directory = directory,id=id)
normalize(id=id,spectra = spectra,directory=directory)
getwd()
WhiteRef <-function(stripe,directory,id){
white <- file.path(directory,paste("WHITEREF_",id,".raw",sep=""))
if(missing(white))  white <- tcltk::tk_choose.files(caption="choose 'WHITEREF' File",filter = Filters)
whiteRow <- createReferenceMeanRow(refFile = white,e = stripe,outFile="WhiteRow.tif",spectra=spectra)
names(whiteRow) <- names(stripe)
#find length of core stripe to break up white
len <- stripe@nrows
#disaggregate whiterow to length
white.ref <- disaggregate(whiteRow,fact = c(1,len))
#set extents to be the same between stripe and reference files
extent(white.ref) <- extent(stripe)
return(white.ref)
}
DarkRef <- function(stripe,directory,id){
dark <- file.path(directory,paste("DARKREF_",id,".raw",sep=""))
if(missing(dark))  dark <- tcltk::tk_choose.files(caption="choose 'DARKREF' File",filter = Filters)
darkRow <- createReferenceMeanRow(refFile=dark,e=stripe,outfile="DarkRow.tif",spectra=spectra)
names(darkRow) <- names(stripe)
len <- stripe@nrows
dark.ref <- disaggregate(darkRow,fact = c(1,len))
extent(dark.ref) <- extent(stripe)
return(dark.ref)
}
overlayR <- function(stripe,white.ref,dark.ref){
normalized <- raster::overlay(stripe,white.ref,dark.ref,fun = normFun,filename = "normalized.tif",overwrite = TRUE)
names(normalized) <- names(stripe)
return(normalized)
}
normalize <- function(id,spectra,directory,tif.path.to.write = NA){
#choose and load the file
raw <- filechooseR(id = id,
spectra = spectra,
directory = directory)
#crop the image
stripe <- cropImage(raw)
#load in the white and dark refs
white.ref <- WhiteRef(stripe,id,directory)
dark.ref <- DarkRef(stripe,id,directory)
#now normalize
normalized <- overlayR(stripe, white.ref, dark.ref)
#optionally write to a tif
if(!is.na(tif.path.to.write)){
writeTif(normalized, path = tif.path.to.write)
}
return(normalized)
}
normalize(id=id,spectra = spectra,directory=directory)
normalize <- function(id,spectra,directory,tif.path.to.write = NA){
#choose and load the file
raw <- filechooseR(id = id,
spectra = spectra,
directory = directory)
#crop the image
stripe <- cropImage(raw = raw)
#load in the white and dark refs
white.ref <- WhiteRef(stripe = stripe,id = id,directory = directory)
dark.ref <- DarkRef(stripe = stripe,id = id,directory = directory)
#now normalize
normalized <- overlayR(stripe = stripe, white.ref = white.ref, dark.ref = dark.ref)
#optionally write to a tif
if(!is.na(tif.path.to.write)){
writeTif(normalized, path = tif.path.to.write)
}
return(normalized)
}
#' Normalize a hyperspectral image
#'
#' @param spectra a vector of wavelengths to extract from the hyperspectral image
#' @param data.file optionally specify the path to the hyperspectral .raw image
#' @param white.ref.file
#' @param dark.ref.file
#' @param another.param
#' @import raster tcltk
#'
#' @return a normalized hyperspectral image
#' @export
#'
#'
filechooseR <- function(id,
directory = NA,
spectra){
Filters <- matrix(c("*",".raw"),1, 2, byrow = TRUE)
data <- file.path(directory,paste(id,".raw",sep=""))
if(missing(data)) data <- tcltk::tk_choose.files(caption="choose Data File",filter = Filters)
filen <- raster::brick(data)
raw <- raster::subset(filen,spectra)
return(raw)
}
cropImage <- function(raw){
image <- raster::subset(raw,c(1,5,8))
raster::plotRGB(raw,c(1,5,8), axes=TRUE, stretch="hist", main="Raw Image")
cropC <- raster::drawExtent()
stripe <- raster::crop(raw,cropC)
names(stripe) <- names(raw)
return(stripe)
}
WhiteRef <-function(stripe,directory,id){
white <- file.path(directory,paste("WHITEREF_",id,".raw",sep=""))
if(missing(white))  white <- tcltk::tk_choose.files(caption="choose 'WHITEREF' File",filter = Filters)
whiteRow <- createReferenceMeanRow(refFile = white,e = stripe,outFile="WhiteRow.tif",spectra=spectra)
names(whiteRow) <- names(stripe)
#find length of core stripe to break up white
len <- stripe@nrows
#disaggregate whiterow to length
white.ref <- disaggregate(whiteRow,fact = c(1,len))
#set extents to be the same between stripe and reference files
extent(white.ref) <- extent(stripe)
return(white.ref)
}
DarkRef <- function(stripe,directory,id){
dark <- file.path(directory,paste("DARKREF_",id,".raw",sep=""))
if(missing(dark))  dark <- tcltk::tk_choose.files(caption="choose 'DARKREF' File",filter = Filters)
darkRow <- createReferenceMeanRow(refFile=dark,e=stripe,outfile="DarkRow.tif",spectra=spectra)
names(darkRow) <- names(stripe)
len <- stripe@nrows
dark.ref <- disaggregate(darkRow,fact = c(1,len))
extent(dark.ref) <- extent(stripe)
return(dark.ref)
}
overlayR <- function(stripe,white.ref,dark.ref){
normalized <- raster::overlay(stripe,white.ref,dark.ref,fun = normFun,filename = "normalized.tif",overwrite = TRUE)
names(normalized) <- names(stripe)
return(normalized)
}
normalize <- function(id,spectra,directory,tif.path.to.write = NA){
#choose and load the file
raw <- filechooseR(id = id,
spectra = spectra,
directory = directory)
#crop the image
stripe <- cropImage(raw = raw)
#load in the white and dark refs
white.ref <- WhiteRef(stripe = stripe,id = id,directory = directory)
dark.ref <- DarkRef(stripe = stripe,id = id,directory = directory)
#now normalize
normalized <- overlayR(stripe = stripe, white.ref = white.ref, dark.ref = dark.ref)
#optionally write to a tif
if(!is.na(tif.path.to.write)){
writeTif(normalized, path = tif.path.to.write)
}
return(normalized)
}
normalize(id=id,spectra = spectra,directory=directory)
